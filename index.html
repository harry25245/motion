<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SOLARIS: OMNI REALITY</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

    body { margin: 0; overflow: hidden; background: #000; font-family: 'Rajdhani', sans-serif; }
    canvas { display: block; position: fixed; top: 0; left: 0; z-index: 1; }
    
    /* UI LAYERS */
    #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
    
    /* START SCREEN */
    #overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.95); z-index: 100;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: opacity 1s;
    }
    h1 { color: #0ff; font-size: 4rem; letter-spacing: 10px; margin: 0; text-shadow: 0 0 20px #0ff; }
    p { color: #888; font-size: 1.2rem; }
    
    #start-btn {
        margin-top: 30px; padding: 15px 50px;
        background: transparent; border: 2px solid #0ff; color: #0ff;
        font-size: 1.5rem; font-family: 'Rajdhani', sans-serif; font-weight: bold;
        cursor: pointer; pointer-events: auto; letter-spacing: 2px;
        box-shadow: 0 0 15px rgba(0,255,255,0.2); transition: 0.3s;
    }
    #start-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 40px #0ff; }

    /* DEBUG CONSOLE (For Errors) */
    #debug-console {
        position: fixed; bottom: 0; left: 0; width: 100%; background: rgba(20,0,0,0.8);
        color: #ff5555; font-family: monospace; padding: 10px; font-size: 12px;
        z-index: 200; display: none; max-height: 100px; overflow-y: auto;
    }

    /* HUD */
    .hud-box {
        position: absolute; padding: 15px; border: 1px solid rgba(0,255,255,0.3);
        background: rgba(0,10,20,0.4); backdrop-filter: blur(5px);
        color: #0ff;
    }
    #hud-left { top: 30px; left: 30px; border-left: 5px solid #0ff; }
    #hud-right { bottom: 30px; right: 30px; text-align: right; border-right: 5px solid #0ff; }
    
    .status-active { color: #0f0; text-shadow: 0 0 5px #0f0; }
    .status-warn { color: #ff0055; text-shadow: 0 0 10px #ff0055; animation: blink 0.5s infinite; display: none; }
    @keyframes blink { 50% { opacity: 0; } }

    #ar-canvas { position: fixed; top: 0; left: 0; z-index: 5; width: 100%; height: 100%; }
    #webcam { display: none; } /* Hide raw video */
</style>
</head>
<body>

<!-- ERROR CONSOLE -->
<div id="debug-console"></div>

<!-- START SCREEN -->
<div id="overlay">
    <h1>SOLARIS</h1>
    <p>IMMERSIVE AUDIO-VISUAL SYSTEM</p>
    <div id="loading-text" style="color: #0ff; margin-top: 10px;">LOADING MODULES...</div>
    <button id="start-btn" style="display:none;">INITIALIZE SYSTEM</button>
</div>

<!-- HUD -->
<div id="ui-layer">
    <div id="hud-left" class="hud-box">
        <div style="font-size: 1.5rem; font-weight: bold;">CORE STATUS</div>
        <div>SYSTEM: <span class="status-active">OPTIMAL</span></div>
        <div>AUDIO ENGINE: <span id="audio-status">OFFLINE</span></div>
    </div>
    <div id="hud-right" class="hud-box">
        <div class="status-warn" id="surge-alert">⚠ ENERGY SURGE ⚠</div>
        <div>HAND TRACKING: <span id="hand-status">SEARCHING...</span></div>
        <div>GESTURES: ACTIVE</div>
    </div>
</div>

<canvas id="ar-canvas"></canvas>
<video id="webcam" autoplay playsinline></video>

<!-- LIBRARIES -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/",
    "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { HandLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";

// --- ERROR HANDLING ---
const debugEl = document.getElementById('debug-console');
window.onerror = function(msg, source, lineno) {
    debugEl.style.display = 'block';
    debugEl.innerHTML += `ERROR: ${msg} at line ${lineno}<br>`;
    document.getElementById('loading-text').innerText = "SYSTEM FAILURE. CHECK CONSOLE.";
    document.getElementById('loading-text').style.color = "red";
};

function log(msg) { console.log(msg); }

// --- AUDIO SYSTEM ---
let audioCtx, osc, gainNode, isAudioInit = false;

function initAudio() {
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        osc = audioCtx.createOscillator();
        gainNode = audioCtx.createGain();
        
        // Deep Drone Sound
        osc.type = 'sawtooth';
        osc.frequency.value = 60;
        
        // Low Pass Filter for muffling
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 400;

        osc.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        osc.start();
        gainNode.gain.value = 0.05; // Low volume start
        
        document.getElementById('audio-status').innerText = "ONLINE";
        document.getElementById('audio-status').classList.add('status-active');
        isAudioInit = true;
    } catch(e) {
        log("Audio failed: " + e);
    }
}

function playZap() {
    if(!isAudioInit) return;
    const zOsc = audioCtx.createOscillator();
    const zGain = audioCtx.createGain();
    zOsc.frequency.setValueAtTime(800, audioCtx.currentTime);
    zOsc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
    zGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    zGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
    zOsc.connect(zGain);
    zGain.connect(audioCtx.destination);
    zOsc.start();
    zOsc.stop(audioCtx.currentTime + 0.2);
}

function playBoom() {
    if(!isAudioInit) return;
    const bOsc = audioCtx.createOscillator();
    const bGain = audioCtx.createGain();
    bOsc.frequency.setValueAtTime(100, audioCtx.currentTime);
    bOsc.frequency.exponentialRampToValueAtTime(0.1, audioCtx.currentTime + 1.0);
    bGain.gain.setValueAtTime(1.0, audioCtx.currentTime);
    bGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
    bOsc.connect(bGain);
    bGain.connect(audioCtx.destination);
    bOsc.start();
    bOsc.stop(audioCtx.currentTime + 1.0);
}

// --- THREE.JS VISUALS ---
let scene, camera, renderer, composer;
let core, particles, ring;
let time = 0;

// Shaders
const vertexShader = `
    uniform float time;
    uniform float explode;
    varying vec2 vUv;
    varying float vNoise;
    
    // Simple noise function
    float random(vec3 scale, float seed) { return fract(sin(dot(gl_Position.xyz + seed, scale)) * 43758.5453 + seed); }

    void main() {
        vUv = uv;
        vec3 pos = position;
        
        // Displacement
        float noise = sin(pos.x * 2.0 + time) * sin(pos.y * 2.0 + time) * sin(pos.z * 2.0 + time);
        vNoise = noise;
        
        // Explosion expansion
        float expansion = explode * 5.0;
        pos += normal * (noise * 0.5 + expansion);
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
`;

const fragmentShader = `
    uniform float time;
    uniform float explode;
    uniform vec3 colorA;
    uniform vec3 colorB;
    varying float vNoise;
    
    void main() {
        vec3 c = mix(colorA, colorB, vNoise * 0.5 + 0.5);
        // Flash white on explode
        c = mix(c, vec3(1.0), explode);
        float glow = 1.0 + explode * 5.0;
        gl_FragColor = vec4(c * glow, 1.0);
    }
`;

function initThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 15;

    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // CORE
    const geo = new THREE.IcosahedronGeometry(4, 30);
    const mat = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            explode: { value: 0 },
            colorA: { value: new THREE.Color(0x00ffff) },
            colorB: { value: new THREE.Color(0x0000ff) }
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
    });
    core = new THREE.Mesh(geo, mat);
    scene.add(core);

    // PARTICLES RING
    const pGeo = new THREE.BufferGeometry();
    const pCount = 2000;
    const pPos = new Float32Array(pCount * 3);
    for(let i=0; i<pCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const r = 7 + Math.random() * 10;
        pPos[i*3] = Math.cos(theta) * r;
        pPos[i*3+1] = (Math.random()-0.5) * 2;
        pPos[i*3+2] = Math.sin(theta) * r;
    }
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const pMat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.1, transparent: true, opacity: 0.8 });
    particles = new THREE.Points(pGeo, pMat);
    scene.add(particles);

    // SHOCKWAVE RING
    const rGeo = new THREE.RingGeometry(6, 6.5, 64);
    const rMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0 });
    ring = new THREE.Mesh(rGeo, rMat);
    ring.rotation.x = Math.PI / 2;
    scene.add(ring);

    // POST PROCESSING
    const renderScene = new RenderPass(scene, camera);
    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloom.strength = 2.0;
    bloom.radius = 0.5;
    
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloom);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        arCanvas.width = window.innerWidth;
        arCanvas.height = window.innerHeight;
    });
}

// --- LOGIC VARS ---
let targetRotX = 0, targetRotY = 0;
let targetZoom = 15;
let isExploding = false;
let explodeVal = 0;
let themeState = 0;

function updateLogic() {
    time += 0.01;
    core.material.uniforms.time.value = time;
    particles.rotation.y = time * 0.2;

    // Smooth Camera
    camera.position.x += (Math.sin(targetRotX) * targetZoom - camera.position.x) * 0.1;
    camera.position.z += (Math.cos(targetRotX) * targetZoom - camera.position.z) * 0.1;
    camera.position.y += (targetRotY * 10 - camera.position.y) * 0.1;
    camera.lookAt(0,0,0);

    // Audio Drone Pitch
    if(isAudioInit) {
        osc.frequency.linearRampToValueAtTime(60 + Math.abs(targetRotX)*50, audioCtx.currentTime + 0.1);
    }

    // Explosion Animation
    if(isExploding) {
        explodeVal += 0.05;
        const peak = Math.sin(explodeVal);
        core.material.uniforms.explode.value = peak > 0 ? peak : 0;
        
        // Ring Expand
        ring.scale.set(1 + explodeVal*4, 1 + explodeVal*4, 1);
        ring.material.opacity = 1.0 - (explodeVal / 3.0);

        if(explodeVal > 3.0) {
            isExploding = false;
            core.material.uniforms.explode.value = 0;
            ring.material.opacity = 0;
            document.getElementById('surge-alert').style.display = 'none';
        }
    }

    composer.render();
    requestAnimationFrame(updateLogic);
}

// --- VISION / AR ---
let handLandmarker;
const video = document.getElementById('webcam');
const arCanvas = document.getElementById('ar-canvas');
const ctx = arCanvas.getContext('2d');
arCanvas.width = window.innerWidth;
arCanvas.height = window.innerHeight;

async function setupAI() {
    try {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 2
        });
        
        document.getElementById('loading-text').innerText = "READY.";
        document.getElementById('start-btn').style.display = "block";

    } catch (e) {
        alert("AI Model Failed to Load. Check Console.");
    }
}

function startCamera() {
    navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: "user" } })
    .then(stream => {
        video.srcObject = stream;
        video.addEventListener('loadeddata', predict);
    })
    .catch(err => alert("Camera Access Denied or Not Found!"));
}

let lastVideoTime = -1;
let pinchLock = false;
let fistLock = false;

function predict() {
    if(video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const results = handLandmarker.detectForVideo(video, performance.now());
        
        ctx.clearRect(0,0,arCanvas.width, arCanvas.height);
        
        if(results.landmarks.length > 0) {
            document.getElementById('hand-status').innerText = "TRACKING " + results.landmarks.length + " HAND(S)";
            document.getElementById('hand-status').style.color = "#0f0";

            // Draw AR Lines
            drawAR(results.landmarks);

            // LOGIC
            if(results.landmarks.length === 1) {
                // 1 Hand: Rotate
                const h = results.landmarks[0][9]; // Middle Finger MCP
                targetRotX = (0.5 - h.x) * 4; // Left/Right
                targetRotY = (0.5 - h.y) * 2; // Up/Down

                // Pinch (Color)
                const thumb = results.landmarks[0][4];
                const index = results.landmarks[0][8];
                const dist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                
                if(dist < 0.05) {
                    if(!pinchLock) {
                        pinchLock = true;
                        changeTheme();
                        playZap();
                    }
                } else pinchLock = false;

                // Fist (Explode)
                const wrist = results.landmarks[0][0];
                const tips = [8,12,16,20];
                let tipAvg = 0;
                tips.forEach(t => tipAvg += Math.hypot(results.landmarks[0][t].x - wrist.x, results.landmarks[0][t].y - wrist.y));
                
                if(tipAvg/4 < 0.25) {
                    if(!fistLock) {
                        fistLock = true;
                        if(!isExploding) {
                            isExploding = true;
                            explodeVal = 0;
                            playBoom();
                            document.getElementById('surge-alert').style.display = 'block';
                        }
                    }
                } else fistLock = false;

            } else if (results.landmarks.length === 2) {
                // 2 Hands: Zoom
                const h1 = results.landmarks[0][9];
                const h2 = results.landmarks[1][9];
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                targetZoom = 30 - (dist * 30); // Far hands = Close zoom
            }
        } else {
            document.getElementById('hand-status').innerText = "SEARCHING...";
            document.getElementById('hand-status').style.color = "#888";
            // Auto rotate if no hands
            targetRotX += 0.002;
        }
    }
    requestAnimationFrame(predict);
}

function drawAR(landmarks) {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#0ff";
    ctx.fillStyle = "#fff";
    
    for(const hand of landmarks) {
        for(const point of hand) {
            const x = (1-point.x) * arCanvas.width;
            const y = point.y * arCanvas.height;
            ctx.beginPath();
            ctx.arc(x,y, 3, 0, Math.PI*2);
            ctx.fill();
        }
    }
}

function changeTheme() {
    themeState = (themeState + 1) % 3;
    if(themeState === 0) {
        core.material.uniforms.colorA.value.setHex(0x00ffff);
        core.material.uniforms.colorB.value.setHex(0x0000ff);
        particles.material.color.setHex(0x00ffff);
    } else if(themeState === 1) {
        core.material.uniforms.colorA.value.setHex(0xffaa00);
        core.material.uniforms.colorB.value.setHex(0xff0000);
        particles.material.color.setHex(0xffaa00);
    } else {
        core.material.uniforms.colorA.value.setHex(0x00ff00);
        core.material.uniforms.colorB.value.setHex(0xccff00);
        particles.material.color.setHex(0x00ff00);
    }
}

// BOOT
initThree();
setupAI();

document.getElementById('start-btn').addEventListener('click', () => {
    initAudio();
    startCamera();
    document.getElementById('overlay').style.opacity = 0;
    setTimeout(() => {
        document.getElementById('overlay').style.display = 'none';
    }, 1000);
    updateLogic();
});

</script>
</body>
</html>

